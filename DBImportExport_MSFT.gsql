CREATE GRAPH MSFT()
CREATE SCHEMA_CHANGE JOB schema_change_job_AddExportedLocalVETypes_JT8B8XV85X78MVIO FOR GRAPH MSFT { 
  ADD VERTEX user(PRIMARY_ID id INT, histry LIST<STRING>, Louvain INT, TopGame STRING) WITH STATS="OUTDEGREE_BY_EDGETYPE", PRIMARY_ID_AS_ATTRIBUTE="true";
  ADD UNDIRECTED EDGE chat_interaction(FROM user, TO user, ChatCount INT);
}
RUN SCHEMA_CHANGE JOB schema_change_job_AddExportedLocalVETypes_JT8B8XV85X78MVIO
DROP JOB schema_change_job_AddExportedLocalVETypes_JT8B8XV85X78MVIO
set exit_on_error = "false"
CREATE LOADING JOB load_job_gr_viz_hist_csv_1645592876433 FOR GRAPH MSFT {
      DEFINE FILENAME MyDataSource;
      LOAD MyDataSource TO VERTEX user VALUES($0, $1, _, _) USING SEPARATOR="\t", HEADER="false", EOL="\n";
    }

set exit_on_error = "true"
set exit_on_error = "false"
CREATE LOADING JOB load_job_gr_viz_party_csv_1645592892244 FOR GRAPH MSFT {
      DEFINE FILENAME MyDataSource;
      LOAD MyDataSource TO EDGE chat_interaction VALUES($0, $1, $2) USING SEPARATOR="\t", HEADER="false", EOL="\n";
    }

set exit_on_error = "true"
set exit_on_error = "false"
CREATE QUERY statistic_result(/* Parameters here */) FOR GRAPH MSFT { 
  /* Write query logic here */ 
  TYPEDEF TUPLE<STRING game, FLOAT score> game_Score;
  
  MapAccum<INT,INT> @@statistic_count;
  MapAccum<INT,MapAccum<STRING,INT>> @@res;
  MapAccum<INT,STRING> @@gameRank;
  HeapAccum<game_Score>(3,score desc) @@final_res;
  
  all = {user.*};
  all = SELECT e FROM all:e ACCUM @@statistic_count+=(e.Louvain->1),
                                  FOREACH i in e.histry DO 
                                          @@res+=(e.Louvain->(i->1))
                                  END;
  
  
  FOREACH (key,value) in @@statistic_count DO
          FOREACH (x,y) in @@res.get(key) DO 
                  @@final_res+=game_Score(x,y);
          END;
          @@gameRank+=(key->@@final_res.pop().game);
          @@final_res.clear();
  
  
  END;
  all = SELECT s FROM all:s POST-ACCUM s.TopGame=@@gameRank.get(s.Louvain);
  print all;
  print @@gameRank;
  print @@statistic_count;
  PRINT "statistic_result works!"; 
}
CREATE QUERY tg_louvain(SET<STRING> v_type, SET<STRING> e_type, STRING wt_attr = "weight", INT max_iter = 10, 
  STRING result_attr = "cid", STRING file_path = "", BOOL print_info = FALSE) {
  /*
  louvain community detection algorithm
  add keyword DISTRIBUTED for cluster environment

  Parameters:
  v_type: vertex types to traverse
  e_type: edge types to traverse
  wt_attr: attribute name for edge weights use empty string is graph is unweighted
  wt_attr type is hardcoded to FLOAT INT or DOUBLE can be supported by changing all `e.getAttr(wt_attr, "FLOAT")`
  to `e.getAttr(wt_attr, "INT")` or `e.getAttr(wt_attr, "DOUBLE")`
  * note: when there is a weight attribute missmatch, there may not be an explicit error message
  all print results showing 0 data are present is an indication that there might be a weight attribute missmatch
  
  max_iter: maximum iteration of louvain optimization
  result_attr: attribute name to assign community id results to; use empty string to skip
  file_path: file path to write CSV output to; use empty string to skip
  print_info: print louvain execution info
  */

  TYPEDEF TUPLE <FLOAT deltaQ, FLOAT weight, VERTEX cc> move;
  SumAccum<FLOAT> @sum_ac; #sum of the degrees of all the vertices in community C of the vertex
  ListAccum<VERTEX> @cc_list; #the community center
  SumAccum<FLOAT> @sum_weight; # total weight incident to this vertex
  SumAccum<FLOAT> @sum_cc_weight; # total weight incident to the cc vertex
  MapAccum<VERTEX,SumAccum<FLOAT>> @A_map; #A[c]: sum of the edge weights for the edges in community c
  MaxAccum<move> @max_best_move; # highest dQ, highest -Outdegree, highest cc
  ListAccum<VERTEX> @cm_list;  #community member list
  SumAccum<FLOAT> @@sum_m; # total edge weight
  SumAccum<INT> @sum_outdegree;   # helper variable for outdegree calculation
  SumAccum<INT> @@sum_cc_change;
  MapAccum<INT, SumAccum<INT>> @@community_map;
  MapAccum<INT, SumAccum<INT>> @@community_size_count;
  FILE f(file_path);

  // initialize
  Start = {v_type};
  Start = SELECT s 
          FROM Start:s -(e_type:e)- :t
          ACCUM
              @@sum_m += e.getAttr(wt_attr, "INT")*0.5,
              s.@sum_weight += e.getAttr(wt_attr, "INT")*1.0,
              s.@sum_cc_weight += e.getAttr(wt_attr, "INT")*1.0,
              s.@sum_outdegree += 1
          // mark @cc only for vertices with more than 1 neighbors
          // and only the marked vertices will participate in the actual louvain algorithm
          // the unmorked vertices will be resolved by the vertex following heuristic
          POST-ACCUM
              IF s.@sum_outdegree > 1 THEN 
                  s.@cc_list += s 
              END;
  IF print_info THEN
      PRINT Start.size() AS AllVertexCount;
  END;

  // special @cc update in the first iteration
  Start = SELECT t 
          FROM Start:s -(e_type:e)- :t
          WHERE s.@sum_outdegree > 1 AND t.@sum_outdegree > 1
          ACCUM
              t.@max_best_move += move(e.getAttr(wt_attr, "INT")*1.0 + @@sum_m*t.@sum_weight * 
              (t.@sum_weight - s.@sum_weight), -s.@sum_cc_weight, s.@cc_list.get(0))
          POST-ACCUM
              IF t.@max_best_move.deltaQ > 0 THEN
                  IF -t.@max_best_move.weight < t.@sum_cc_weight THEN
                      t.@cc_list.clear(),
                      t.@cc_list += t.@max_best_move.cc,
                      t.@sum_cc_weight = -t.@max_best_move.weight,
                      @@sum_cc_change += 1
                  ELSE
                      IF -t.@max_best_move.weight == t.@sum_cc_weight AND getvid(t) < getvid(t.@max_best_move.cc)  THEN
                          t.@cc_list.clear(),
                          t.@cc_list += t.@max_best_move.cc,
                          t.@sum_cc_weight = -t.@max_best_move.weight,
                          @@sum_cc_change += 1
                      END
                  END
              END;
  IF print_info THEN
      PRINT @@sum_cc_change AS InitChangeCount;
  END;

  // main loop
  WHILE @@sum_cc_change > 0 LIMIT max_iter DO
      // initialize for iteration
      @@sum_cc_change = 0;
      Start = SELECT s 
              FROM Start:s
              WHERE s.@sum_outdegree > 1
              POST-ACCUM
                  s.@sum_ac = 0,
                  s.@cm_list.clear(),
                  s.@A_map.clear();

      Start = SELECT s 
              FROM Start:s
              ACCUM
                  FOREACH v IN s.@cc_list DO
                      CASE WHEN getvid(v) != -1 THEN 
                          v.@cm_list += s 
                      END
                  END;

      Start = SELECT s 
              FROM Start:s -(e_type:e)- :t
              WHERE t.@sum_outdegree > 1
              ACCUM 
                  s.@A_map += (t.@cc_list.get(0) -> e.getAttr(wt_attr, "INT")*1.0);

      Start = SELECT s 
              FROM Start:s
              ACCUM
                  FOREACH v IN s.@cc_list DO
                      CASE WHEN getvid(v) != -1 THEN 
                          v.@sum_ac += s.@sum_weight 
                      END
                  END;

      Start = SELECT s 
              FROM Start:s
              ACCUM
                  FOREACH v IN s.@cm_list DO
                      CASE WHEN getvid(v) != -1 THEN 
                          v.@sum_ac = s.@sum_ac 
                      END
                  END;

      // compute @max_dQ
      Start = SELECT s 
              FROM Start:s -(e_type:e)- :t
              WHERE t.@sum_outdegree > 1
              ACCUM
                  INT A_s = 0,
                  IF s.@A_map.containsKey(s) THEN 
                      A_s = s.@A_map.get(s) 
                  END,
                  s.@max_best_move += move(s.@A_map.get(t.@cc_list.get(0)) - A_s + 
                  1/@@sum_m*s.@sum_weight*(s.@sum_ac-t.@sum_ac), -t.@sum_cc_weight, t.@cc_list.get(0))
              POST-ACCUM
                  IF s.@max_best_move.deltaQ > 0 THEN
                      IF -s.@max_best_move.weight < s.@sum_cc_weight THEN   // smallest best_move weight < current weight
                          s.@cc_list.clear(),
                          s.@cc_list += s.@max_best_move.cc,
                          s.@sum_cc_weight = -s.@max_best_move.weight,
                          @@sum_cc_change += 1
                      ELSE
                          IF -s.@max_best_move.weight == s.@sum_cc_weight AND getvid(s.@cc_list.get(0)) < getvid(s.@max_best_move.cc)  THEN
                              s.@cc_list.clear(),
                              s.@cc_list += s.@max_best_move.cc,
                              s.@sum_cc_weight = -s.@max_best_move.weight,
                              @@sum_cc_change += 1
                          END
                      END
                  END;
      IF print_info THEN
          PRINT @@sum_cc_change AS IterChangeCount;
      END;
  END;

  // process node with outdegree=1
  // follow the vertex to its neighbor's community
  // if the neighbor also have outdegree=1, mark the two vertices as one community
  Start = {v_type};
  Start = SELECT s 
          FROM Start:s -(e_type:e)- :t
          WHERE s.@sum_outdegree == 1 AND t.@sum_outdegree != 1
          ACCUM 
              s.@cc_list += t.@cc_list.get(0);
  IF print_info THEN
      PRINT Start.size() AS VertexFollowedToCommunity;
  END;

  Start = {v_type};
  Start = SELECT s 
          FROM Start:s -(e_type:e)- :t
          WHERE s.@sum_outdegree == 1 AND t.@sum_outdegree == 1
          ACCUM
              IF getvid(s) <= getvid(t) THEN
                  s.@cc_list += s
              ELSE
                  s.@cc_list += t
              END;
  IF print_info THEN
      PRINT Start.size() AS VertexFollowedToVertex;
  END;

  // process node with outdegree=0
  // assign them to communities containing only itself
  Start = {v_type};
  Start = SELECT s 
          FROM Start:s
          WHERE s.@sum_outdegree == 0
          ACCUM 
              s.@cc_list += s;
  IF print_info THEN
      PRINT Start.size() AS VertexAssignedToItself;
  END;

  // save result
  Start = {v_type};
  Start = SELECT s 
          FROM Start:s
          POST-ACCUM
              IF result_attr != "" THEN 
                  s.setAttr(result_attr, getvid(s.@cc_list.get(0))) 
              END,
              IF file_path != "" THEN 
                  f.println(s, getvid(s.@cc_list.get(0))) 
              END;

  // print result satistic
  IF print_info THEN
      Start = SELECT s 
              FROM Start:s
              WHERE s.@cc_list.size() > 0
              POST-ACCUM
                  @@community_map += (getvid(s.@cc_list.get(0)) -> 1);
      PRINT @@community_map.size() AS FinalCommunityCount;
  END;
}
CREATE QUERY tg_degree_cent(SET<STRING> v_type, SET<STRING> e_type, SET<STRING> re_type, BOOL in_degree = TRUE, BOOL out_degree = TRUE,
  INT top_k=100, BOOL print_accum = TRUE, STRING result_attr = "",STRING file_path = "") {
  /* Compute degree Centrality for each VERTEX.
  Parameters:
  v_type: vertex types to traverse
  e_type: edge types to traverse
  re_type: for indegree use
  in_degree: if you want to count incoming relationships, set it to TRUE
  out_degree: if you want to count outcoming relationships, set it to TRUE
  top_k: report only this many top scores          print_accum: weather print the result
  result_attr: attribute to write result to        file_path: file to write CSV output to
  for undirected graph, you only need to set e_type and indegree
   */
  TYPEDEF TUPLE<VERTEX Vertex_ID, FLOAT score> Vertex_Score;
  HeapAccum<Vertex_Score>(top_k, score DESC) @@top_scores_heap;
  SumAccum<INT> @sum_degree_score;
  FILE f (file_path);

  all = {v_type};
  sll = SELECT s 
        FROM all:s
        ACCUM IF in_degree THEN
                 FOREACH edge_type in re_type DO
                     s.@sum_degree_score+=s.outdegree(edge_type)
                 END
              END,
              IF out_degree THEN
                  FOREACH edge_type in e_type DO
                      s.@sum_degree_score+=s.outdegree(edge_type)
                  END
              END;
  #Output
  IF file_path != "" THEN
      f.println("Vertex_ID", "Degree");
  END;

  Start = SELECT s 
          FROM all:s
    POST-ACCUM
        IF result_attr != "" THEN 
                  s.setAttr(result_attr, s.@sum_degree_score) 
              END,
    
        IF print_accum THEN 
                  @@top_scores_heap += Vertex_Score(s, s.@sum_degree_score) 
              END,
    
        IF file_path != "" THEN 
                  f.println(s, s.@sum_degree_score) 
              END;
        
   IF print_accum THEN
       PRINT @@top_scores_heap AS top_scores;
   END;
}
CREATE QUERY print_louvain2(string file1="/home/tigergraph/algorithm/edge.csv",
  string file2="/home/tigergraph/algorithm/node.csv",int range1,int range2,int sample1=3,INT limit1,bool one_hop,BOOL two_hop,bool three_hop) FOR GRAPH MSFT { 
  /* Write query logic here */
  TYPEDEF TUPLE <INT sizee,int countt> community_size;
  MapAccum<INT,INT> @@size;
  MapAccum<INT,SetAccum<INT>> @@res;
  HeapAccum<community_size>(30,sizee desc) @@rank;
  SetAccum<INT> @@community_list;
  SetAccum<INT> @@current_list;
  MaxAccum<INT> @id;
  OrAccum @visited;
  start = {user.*};
  FILE f3 (file1);
  FILE f4 (file2);
  f3.println("node1","node2","size");
  f4.println("node","Louvain","size");
  start = {user.*};
  start = SELECT s FROM start:s ACCUM @@size+=(s.Louvain->1);
  FOREACH (key,value) in @@size DO
        @@res+=(value->key);
  END;
  FOREACH (KEY,value) in @@res DO
        @@rank+=community_size(KEY,value.size());
  END;
  print @@rank;
  int countt=1;
  FOREACH i in RANGE[range1,range2] DO
      
      @@community_list+=@@res.get(i);
      
      
  END;
  int ttt = (450.0-320.0)/@@community_list.size()*1.0;
  FOREACH i in @@community_list DO
      cur = SELECT t FROM start:s-(chat_interaction)-user:t 
                    WHERE s.Louvain==i and t.Louvain==i
                    ACCUM f3.println(s,t,@@size.get(t.Louvain)*10),s.@visited+=TRUE,t.@visited+=TRUE 
                    POST-ACCUM f4.println(s,320000000+countt*ttt*1000000,@@size.get(s.Louvain)*10)
                    POST-ACCUM f4.println(t,320000000+countt*ttt*1000000,@@size.get(t.Louvain)*10);
      countt+=1;
  END;
  start = SELECT t FROM start:t WHERE t.Louvain in @@community_list;
  IF one_hop THEN
  start = SELECT t FROM start:s-(chat_interaction)-user:t 
                    SAMPLE sample1 EDGE WHEN s.outdegree()>0
                    
                    ACCUM f3.println(s,t,@@size.get(t.Louvain)+(t.id*1.0/1000000.0)),s.@visited+=TRUE 
                    POST-ACCUM IF t.@visited!=TRUE THEN f4.println(t,t.Louvain,@@size.get(t.Louvain)+(t.id*1.0/1000000.0)) END,t.@visited+=TRUE
                    LIMIT limit1;
  END;
  IF two_hop THEN
  start = SELECT t FROM start:s-(chat_interaction)-user:t 
                    SAMPLE sample1 EDGE WHEN s.outdegree()>0
                    
                    ACCUM f3.println(s,t,@@size.get(t.Louvain)+(t.id*1.0/1000000.0)),s.@visited+=TRUE
                    POST-ACCUM IF t.@visited!=TRUE THEN f4.println(t,t.Louvain,@@size.get(t.Louvain)+(t.id*1.0/1000000.0)) END,t.@visited+=TRUE LIMIT limit1;
  END;
  IF three_hop THEN
  start = SELECT t FROM start:s-(chat_interaction)-user:t 
                    SAMPLE sample1 EDGE WHEN s.outdegree()>0
                    
                    ACCUM f3.println(s,t,@@size.get(t.Louvain)+(t.id*1.0/1000000.0)),s.@visited+=TRUE
                    POST-ACCUM IF t.@visited!=TRUE THEN f4.println(t,t.Louvain,@@size.get(t.Louvain)+(t.id*1.0/1000000.0)) END,t.@visited+=TRUE;
  END;
  PRINT "print_louvain works!"; 
}
CREATE QUERY print_louvain(/* Parameters here */) FOR GRAPH MSFT { 
  /* Write query logic here */
  TYPEDEF TUPLE <INT sizee,int countt> community_size;
  MapAccum<INT,INT> @@size;
  MapAccum<INT,SetAccum<INT>> @@res;
  HeapAccum<community_size>(30,sizee desc) @@rank;
  SetAccum<INT> @@community_list;
  MaxAccum<INT> @id;
  OrAccum @visited;/*
  start = {user.*};
  FILE f1 ("/home/tigergraph/edge.csv");
  FILE f2 ("/home/tigergraph/node.csv");
  f1.println("node1","node2");
  f2.println("node","Louvain","Game");
  start = SELECT s FROM start:s LIMIT 2;
  while start.size()<2 DO
        start = SELECT s FROM start-(chat_interaction)-user:s;
  END;
  start = SELECT s FROM start:s-(chat_interaction)-user:t 
                    ACCUM f1.println(s,t) 
                    POST-ACCUM f2.println(s,s.Louvain,s.TopGame)
                    POST-ACCUM f2.println(t,t.Louvain,t.TopGame);*/
  #############################################################################################################################################
  start = {user.*};
  start = SELECT s FROM start:s ACCUM @@size+=(s.Louvain->1);
  FOREACH (key,value) in @@size DO
        @@res+=(value->key);
  END;
  FOREACH (KEY,value) in @@res DO
        @@rank+=community_size(KEY,value.size());
  END;
  print @@rank;
  @@community_list+=@@res.get(25);
  current = SELECT s FROM start:s WHERE s.Louvain in @@community_list; 
  print current;
  @@community_list+=@@res.get(24);
  @@community_list+=@@res.get(23);
  @@community_list+=@@res.get(22);/*
  @@community_list+=@@res.get(20);
  @@community_list+=@@res.get(16);
  @@community_list+=@@res.get(17);
  @@community_list+=@@res.get(18);*/
  
  print @@community_list;
  start = {user.*};
  FILE f3 ("/home/tigergraph/algorithm/edge13.csv");
  FILE f4 ("/home/tigergraph/algorithm/node13.csv");
  f3.println("node1","node2");
  f4.println("node","Louvain","size");
  cur = SELECT s FROM start:s WHERE s.Louvain in @@community_list;
  print cur;
  start = SELECT t FROM start:s-(chat_interaction)-user:t 
                    WHERE s.Louvain in @@community_list and t.Louvain in @@community_list
                    ACCUM f3.println(s,t),s.@visited+=TRUE,t.@visited+=TRUE 
                    POST-ACCUM f4.println(s,s.Louvain,@@size.get(s.Louvain)*10)
                    POST-ACCUM f4.println(t,t.Louvain,@@size.get(t.Louvain)*10);
  start = SELECT t FROM start:s-(chat_interaction)-user:t 
                    SAMPLE 2 EDGE WHEN s.outdegree()>0
                    WHERE t.@visited!=TRUE
                    ACCUM f3.println(s,t),s.@visited+=TRUE,t.@visited+=TRUE 
                    POST-ACCUM f4.println(t,t.Louvain,@@size.get(t.Louvain)+(t.id*1.0/1000000.0))
                    LIMIT 30;
  start = SELECT t FROM start:s-(chat_interaction)-user:t 
                    SAMPLE 3 EDGE WHEN s.outdegree()>0
                    WHERE t.@visited!=TRUE
                    ACCUM f3.println(s,t),s.@visited+=TRUE,t.@visited+=TRUE
                    POST-ACCUM f4.println(t,t.Louvain,@@size.get(t.Louvain)+(t.id*1.0/1000000.0))LIMIT 30;
  start = SELECT t FROM start:s-(chat_interaction)-user:t 
                    SAMPLE 3 EDGE WHEN s.outdegree()>0
                    WHERE t.@visited!=TRUE
                    ACCUM f3.println(s,t),s.@visited+=TRUE,t.@visited+=TRUE
                    POST-ACCUM f4.println(t,t.Louvain,@@size.get(t.Louvain)+(t.id*1.0/1000000.0));
  
  PRINT "print_louvain works!"; 
}
set exit_on_error = "true"
